Охарактеризовать структура Web-страницы (обычная, с семантической разметкой).
**Обычная (не семантическая) структура** традиционно основывалась на блочном делении с использованием тега **`<div>`** для всех функциональных областей (шапка, меню, контент, подвал). Это затрудняет автоматический анализ содержимого поисковыми системами и программами для чтения с экрана (скринридерами). **Семантическая разметка (HTML5)** использует специальные теги, которые несут смысловую нагрузку и описывают роль контента на странице. Основные теги: **`<header>`** (шапка), **`<nav>`** (навигация), **`<main>`** (основное содержимое), **`<article>`** (самостоятельный, независимый блок контента), **`<section>`** (тематический раздел) и **`<footer>`** (подвал). Такая структура улучшает **SEO** и **доступность (Accessibility)**.

  Описать форматирование текста, изменение шрифта, заголовки, списки в HTML.
**Форматирование текста** в HTML разделяется на логическое и физическое. Логическое (семантическое) форматирование: **`<strong>`** (важность), **`<em>`** (акцент). Физическое (визуальное): **`<b>`** (полужирный, без важности), **`<i>`** (курсив). **Изменение шрифта** и его параметров (семейство, размер, начертание) полностью контролируется **CSS** (свойства `font-family`, `font-size`, `font-weight`). **Заголовки** обозначаются тегами от **`<h1>`** (главный заголовок страницы) до **`<h6>`** (наименьший подзаголовок), определяя иерархию документа. **Списки**: **`<ul>`** (unordered list) — ненумерованный, маркерами; **`<ol>`** (ordered list) — нумерованный, цифрами или буквами; **`<dl>`** — список определений.

  Описать вставку рисунков и таблиц в HTML.
**Рисунки** вставляются самозакрывающимся тегом **`<img>`**. Обязательные атрибуты: **`src`** (Source — путь к файлу изображения) и **`alt`** (Alternative text — текстовое описание для поисковиков и скринридеров). Рекомендуется использовать атрибуты **`width`** и **`height`** для предотвращения "прыжков" макета при загрузке. **Таблицы** создаются с помощью тега **`<table>`** как контейнера. Структура: **`<tr>`** (table row) — строка таблицы; **`<th>`** (table header) — ячейка заголовка; **`<td>`** (table data) — ячейка данных. Для семантической группировки используются **`<thead>`**, **`<tbody>`**, **`<tfoot>`**.

  Описать формы. Способы передачи данных на сервер, описать их.
**Форма** — элемент **`<form>`**, предназначенный для сбора данных от пользователя и их последующей отправки на сервер. Основные атрибуты: **`action`** (URL скрипта-обработчика на сервере) и **`method`** (HTTP-метод отправки). Способы передачи:
1.  **GET**: Данные формы добавляются к **URL** в виде строки запроса (`?key=value&...`). Видимы в адресной строке, имеют ограничение по объему. Используется для получения данных (поиск, фильтрация).
2.  **POST**: Данные отправляются в **теле HTTP-запроса**. Невидимы, нет строгих ограничений по объему. Используется для отправки данных, которые изменяют состояние на сервере (регистрация, создание статьи).

  Элементы формы, назначение и виды.
**Элементы формы** служат для организации ввода данных пользователем. Основные элементы:
* **`<input>`**: Самый универсальный элемент, его назначение определяется атрибутом **`type`**. **Виды input**: `text`, `password`, `email`, `number`, `date`, `checkbox` (множественный выбор), `radio` (единичный выбор), `submit` (кнопка отправки), `file` (загрузка файла).
* **`<textarea>`**: Для ввода многострочного текста.
* **`<select>`** и **`<option>`**: Для создания выпадающих списков.
* **`<button>`**: Кнопка, может быть типа `submit`, `reset` или `button`.
Назначение: **Сбор структурированных данных** и обеспечение **интерактивности** страницы. Элемент **`<label>`** используется для связывания текста с полем ввода, улучшая доступность.

  Определить назначение каскадных таблиц стилей (CSS).
**CSS (Cascading Style Sheets)** — формальный язык, предназначенный для **описания внешнего вида** (стиля) документа, написанного на языке разметки (HTML). Основное назначение:
1.  **Разделение ответственности (Separation of Concerns)**: Отделение структуры (HTML) от представления (CSS), что делает код чище и проще для поддержки.
2.  **Повторное использование**: Один и тот же файл стилей может быть применен к множеству HTML-страниц, обеспечивая единообразие дизайна.
3.  **Адаптивность**: Использование медиа-запросов (`@media`) в CSS позволяет адаптировать дизайн под разные устройства и размеры экрана.

  Описать синтаксис CSS.
Правила CSS состоят из двух основных частей: **селектора** и **блока объявлений**.
* **Селектор**: Указывает, к каким HTML-элементам должны быть применены стили (например, `p`, `.class`, `#id`).
* **Блок объявлений**: Заключен в **фигурные скобки `{}`** и содержит одно или несколько **объявлений**.
* **Объявление**: Состоит из пары **свойство** и **значение**, разделенных **двоеточием** и завершенных **точкой с запятой** (напр.: `color: blue; font-size: 16px;`).

  Описать способы подключения каскадных таблиц стилей, привести примеры.
Существует три основных способа подключения CSS к HTML-документу:
1.  **Внешние таблицы стилей (External)**: Самый распространенный и рекомендуемый метод. CSS находится в отдельном файле с расширением **`.css`** и подключается в секции `<head>`: `<link rel="stylesheet" href="styles.css">`.
2.  **Внутренние стили (Internal)**: Стиль определяется непосредственно в HTML-файле внутри тега **`<style>`**, который размещается в секции `<head>`: `<style>h1 { color: red; }</style>`.
3.  **Инлайновые стили (Inline)**: Стиль применяется к конкретному элементу через атрибут **`style`**. Имеет наивысший приоритет, но не рекомендуется для общего оформления: `<p style="margin-left: 10px; color: green;">Текст</p>`.

  Дать определение селекторам.
**Селектор** — это шаблон, используемый в CSS для **выбора (таргетирования)** одного или нескольких HTML-элементов, к которым должны быть применены объявленные правила стиля. Селекторы позволяют указать точные критерии для стилизации. Основные виды:
* **По тегу**: `p`, `a` (стилизует все теги).
* **По классу**: `.my-class` (стилизует элементы с атрибутом `class="my-class"`).
* **По ID**: `#unique-id` (стилизует один уникальный элемент).
* **Комбинаторные**: `div p` (выбор потомков), `div > p` (выбор непосредственных потомков).
* **По атрибуту**: `[type="submit"]` (выбор элементов с определенным атрибутом).

  Дать определение псевдо-классам CSS. Привести примеры.
**Псевдо-класс** — это ключевое слово, добавляемое к селектору через двоеточие (**`:`**), которое определяет **специальное, динамическое состояние** выбранного элемента или его положение в структуре дерева DOM. Это позволяет применять стили в ситуациях, которые не могут быть определены простыми селекторами.
* **Примеры состояния пользователя**:
    * `:hover` (элемент, на который наведен курсор).
    * `:focus` (элемент, находящийся в фокусе, например, поле ввода).
    * `:active` (элемент, нажатый пользователем).
    * `:link`, `:visited` (непосещенные/посещенные ссылки).
* **Примеры структурного положения**:
    * `:first-child` (первый потомок родителя).
    * `:nth-child(2n)` (каждый второй потомок).

  Дать определение псевдо-элементам CSS. Привести примеры.
**Псевдо-элемент** — это ключевое слово, добавляемое к селектору через **двойное двоеточие (`::`)**, которое позволяет стилизовать **определенную часть элемента** или **вставить декоративный контент** до или после содержимого элемента. В отличие от псевдо-классов, которые описывают состояние, псевдо-элементы создают виртуальные, невидимые в DOM, элементы.
* **Примеры:**
    * **`::before`** и **`::after`**: Используются для вставки сгенерированного контента (свойство `content`) до или после содержимого выбранного элемента. Часто применяются для декоративных иконок или стрелок.
    * **`::first-line`**: Применяет стили только к **первой строке** текста внутри элемента (например, первого абзаца).
    * **`::first-letter`**: Применяет стили только к **первой букве** текста, позволяя создавать, например, буквицы.
    * **`::selection`**: Стилизует текст, который в данный момент **выделен** пользователем.

  Описать адаптивную верстку страниц при помощи CSS, назвать подходы к адаптивной верстке.
**Адаптивная верстка (Responsive Web Design)** — это подход к веб-разработке, при котором дизайн и контент страницы **автоматически подстраиваются** под размер и ориентацию экрана, на котором они просматриваются (ПК, планшет, смартфон). Это обеспечивает удобство использования на любом устройстве.
**Основные подходы:**
1.  **Медиа-запросы (Media Queries)**: Правила CSS, которые позволяют применять различные стили в зависимости от характеристик устройства (ширина, высота, ориентация). Например, `@media (max-width: 600px) { ... }`.
2.  **Гибкая (Резиновая) Сетка (Fluid Grids)**: Использование **относительных единиц** (проценты, `vw`) вместо фиксированных пикселей для размеров контейнеров и столбцов. Это позволяет макету растягиваться или сжиматься пропорционально.
3.  **Гибкие Изображения (Flexible Images)**: Использование свойства `max-width: 100%;` для изображений, чтобы они не выходили за пределы своего контейнера, масштабируясь при необходимости.
4.  **Mobile First**: Философия проектирования, при которой разработка начинается с создания макета для **самых маленьких экранов**, а затем стили добавляются для более крупных устройств. Это обеспечивает высокую производительность на мобильных устройствах.

  Определить управление положением на странице (свойства left, top, z-index, position, visibility, overflow).
Данные свойства CSS используются для точного контроля над геометрией и расположением элементов:
* **`position`**: Определяет тип позиционирования элемента. Основные значения:
    * **`static`** (по умолчанию): Элемент находится в нормальном потоке.
    * **`relative`**: Позиционируется относительно самого себя, сохраняя место в потоке. Свойства `top/left/right/bottom` работают.
    * **`absolute`**: Позиционируется относительно ближайшего **нестатического** предка. Удаляется из нормального потока.
    * **`fixed`**: Позиционируется относительно **окна браузера** (viewport) и не прокручивается.
    * **`sticky`**: Ведет себя как `relative`, пока не достигнет порогового значения, после чего становится `fixed`.
* **`left`, `top`, `right`, `bottom`**: Используются для **смещения** позиционированного элемента (`relative`, `absolute`, `fixed`, `sticky`) относительно его точки отсчета.
* **`z-index`**: Определяет **порядок наложения** элементов, позиционированных вне обычного потока. Чем выше значение, тем "ближе" к пользователю находится элемент.
* **`visibility`**: Управляет видимостью элемента. **`hidden`** делает элемент невидимым, но **он сохраняет свое место** в макете.
* **`overflow`**: Определяет, как браузер должен обрабатывать контент, который **выходит за границы** элемента. Значения: **`visible`** (видно), **`hidden`** (обрезано), **`scroll`** (появляются полосы прокрутки всегда), **`auto`** (полосы прокрутки появляются при необходимости).

  Описать flex модель.
**Flexbox (Flex Container)** — это **одномерная** модель верстки в CSS, предназначенная для выравнивания и распределения пространства между элементами (**флекс-элементами**) в контейнере **вдоль одной оси** (горизонтальной или вертикальной).
**Основные особенности:**
* **Гибкость**: Элементы могут сжиматься или растягиваться для заполнения доступного пространства.
* **Выравнивание**: Легкое выравнивание элементов по горизонтали (`justify-content`) и по вертикали (`align-items`).
* **Независимость от порядка**: Порядок элементов в разметке можно изменить, используя свойство `order`, без изменения HTML-кода.
* **Свойство `display: flex;`** превращает элемент в флекс-контейнер.

  Описать Grid модель.
**CSS Grid Layout** — это **двумерная** модель верстки, позволяющая создавать сложные структуры и макеты, выравнивая элементы одновременно **по строкам и столбцам**.
**Основные особенности:**
* **Сетка**: Определяется через свойства `grid-template-rows` и `grid-template-columns`.
* **Области (Areas)**: Элементы могут быть размещены в именованных областях сетки, что делает макет интуитивно понятным (`grid-template-areas`).
* **Единица `fr`**: Позволяет распределять свободное пространство между столбцами/строками пропорционально.
* **Свойство `display: grid;`** превращает элемент в грид-контейнер. Grid идеален для **макета всей страницы**, в то время как Flexbox часто используется для компонентов или одномерных блоков внутри макета.

  Определить анимации в CSS (переходы, ключевые кадры).
Анимации в CSS позволяют плавно изменять внешний вид элементов, делая интерфейс более отзывчивым и привлекательным.
1.  **Переходы (Transitions)**: Обеспечивают **плавный переход** между двумя состояниями элемента, когда его свойство меняется (например, при наведении курсора).
    * Свойства: `transition-property` (какое свойство анимировать), `transition-duration` (время перехода), `transition-timing-function` (скорость перехода), `transition-delay` (задержка перед началом).
    * **Пример:** `transition: color 0.5s ease;`
2.  **Ключевые Кадры (Keyframes)**: Используются для создания **сложных, многоступенчатых анимаций**. Они определяются с помощью правила **`@keyframes`**, где задаются стили элемента на разных этапах анимации (от 0% до 100%).
    * Свойства: `animation-name` (имя ключевого кадра), `animation-duration` (длительность), `animation-iteration-count` (количество повторов).
    * **Пример:** `@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }`

  Описать JavaScript, назначение, размещение, основные операторы.
**JavaScript** — это высокоуровневый, интерпретируемый скриптовый язык программирования.
* **Назначение**: Изначально был создан для **добавления интерактивности** на веб-страницы (обработка событий, анимация, валидация форм). Сегодня используется для клиентской части, серверной части (Node.js) и мобильных приложений.
* **Размещение**:
    1.  Во **внешнем файле** (`.js`), подключаемом в HTML: `<script src="script.js"></script>`. Рекомендуется размещать тег перед закрывающим `</body>` для ускорения загрузки страницы.
    2.  **Встроенный код** в теге `<script>` внутри HTML-документа.
* **Основные операторы:**
    * **Присваивание**: `=`, `+=`, `-=`.
    * **Арифметические**: `+`, `-`, `*`, `/`, `%` (остаток).
    * **Сравнения**: `==`, `===` (строгое), `!=`, `!==`, `>`, `<`.
    * **Логические**: `&&` (И), `||` (ИЛИ), `!` (НЕ).
    * **Условные**: `if/else`, `switch`.
    * **Циклы**: `for`, `while`, `do...while`, `for...in` (для объектов), `for...of` (для массивов).

  Описать обработку событий средствами DHTML. Описать DHTML.
**DHTML (Dynamic HTML)** — это собирательный термин (в основном устаревший), обозначающий комбинацию трех технологий: **HTML** (структура), **CSS** (стиль) и **JavaScript** (поведение и интерактивность).
**Обработка событий** — это механизм, позволяющий JavaScript-коду реагировать на действия пользователя (например, клик мыши, нажатие клавиши, ввод текста) или на изменения в браузере (загрузка страницы, изменение размера окна).
* **Способы назначения обработчика:**
    1.  **HTML-атрибуты**: `<button onclick="myFunction()">Клик</button>` (самый старый, не рекомендуется).
    2.  **Свойства DOM**: `element.onclick = myFunction;`.
    3.  **Метод `addEventListener`**: Самый современный и гибкий способ, позволяет назначить несколько обработчиков на одно событие: `element.addEventListener('click', myFunction);`.
В результате обработки события DHTML может динамически изменить стили элемента (CSS) или его структуру (HTML).

  Дать определение массивам. Методы работы с массивами.
**Массив (Array)** в JavaScript — это **упорядоченная коллекция** значений, которая может содержать данные любого типа (числа, строки, объекты, другие массивы). Элементы массива идентифицируются по **числовому индексу**, начиная с 0.
**Основные методы работы:**
* **Изменение длины/состава:**
    * `push(item)`: Добавляет элемент в **конец**.
    * `pop()`: Удаляет элемент с **конца**.
    * `unshift(item)`: Добавляет элемент в **начало**.
    * `shift()`: Удаляет элемент с **начала**.
    * `splice(start, count, ...items)`: Универсальный метод для добавления, удаления и замены элементов по произвольному индексу.
* **Перебор и преобразование:**
    * `forEach(func)`: Выполняет функцию для каждого элемента.
    * `map(func)`: Создает **новый массив**, применяя функцию к каждому элементу.
    * `filter(func)`: Создает **новый массив**, включающий только те элементы, для которых функция вернула `true`.
    * `reduce(func, initial)`: Последовательно обрабатывает массив, сводя его к **одному значению**.

  Определить функции и методы функций.
**Функция** — это именованный (или анонимный) блок кода, предназначенный для выполнения конкретной задачи. Функции являются **объектами первого класса** в JavaScript, что означает, что их можно присваивать переменным, передавать как аргументы и возвращать из других функций.
**Методы функций** (называемые также методами прототипа `Function`) используются для **управления контекстом вызова** (`this`) функции или для **связывания** функции с определенным контекстом.
* **`call(context, arg1, arg2, ...)`**: Вызывает функцию, явно устанавливая контекст `this` (первый аргумент). Аргументы передаются **списком**.
* **`apply(context, [arg1, arg2, ...])`**: Похож на `call`, но аргументы передаются **массивом**.
* **`bind(context, arg1, arg2, ...)`**: **Не вызывает** функцию, а **возвращает новую функцию**, жестко привязанную к заданному контексту `this` и, при необходимости, к предварительно заданным аргументам.

Определить понятие области видимости в переменных.
**Область видимости (Scope)** — это контекст, который определяет **доступность** переменных, функций и объектов в разных частях программы. Она обеспечивает изоляцию кода, предотвращая конфликты имен.
В JavaScript существует три основных типа области видимости:
1.  **Глобальная область (Global Scope)**: Переменная, объявленная вне всех функций или блоков. Доступна **из любой точки** кода.
2.  **Функциональная область (Function/Local Scope)**: Переменная, объявленная внутри функции, обычно с помощью ключевого слова **`var`**. Доступна только **внутри этой функции**.
3.  **Блочная область (Block Scope)**: Переменная, объявленная внутри блока кода (например, внутри `if`, `for` или просто `{}`) с использованием ключевых слов **`let`** или **`const`** (введено в ES6). Доступна только **внутри этого блока**.
    **Лексическая область видимости (Lexical Scope)**: Означает, что область видимости определяется местом, **где функция была написана**, а не местом, где она была вызвана.

Описать принцип работы функций временной задержки.
Функции временной задержки (`setTimeout` и `setInterval`) являются частью **Web API** (или Node.js API), а не самого движка JavaScript, и используются для **асинхронного** выполнения кода.
1.  **`setTimeout(callback, delayInMilliseconds)`**:
      * Выполняет функцию **`callback`** **один раз** после того, как истечет указанная задержка (`delay`).
      * Время задержки гарантирует, что выполнение произойдет **не ранее** указанного времени, но может произойти и позже, если основной поток JavaScript занят.
      * Возвращает уникальный идентификатор, который можно использовать для отмены выполнения (`clearTimeout`).
2.  **`setInterval(callback, delayInMilliseconds)`**:
      * Выполняет функцию **`callback`** **многократно** через каждый указанный интервал времени.
      * Используется для создания **периодических действий** (например, часы, таймер).
      * Возвращает идентификатор, который используется для остановки повторений (`clearInterval`).
        Обе функции являются **асинхронными**, то есть они не блокируют выполнение основного кода.

Описать объекты в JavaScript.
**Объект** в JavaScript — это коллекция, состоящая из **свойств** и **методов**. Объекты являются базовым элементом структуры данных и используются для моделирования реальных сущностей.
  * **Свойства (Properties)**: Пары "ключ: значение" (`key: value`), где ключ — строка (или символ), а значение — любой тип данных.
  * **Методы (Methods)**: Функции, которые хранятся как свойства объекта и выполняют действия, связанные с этим объектом.
    Объекты могут быть созданы с использованием **литерала объекта** (`{}`), **конструктора** (`new Object()`) или **класса** (`new ClassName()`). Вся структура JavaScript основана на объектах, включая массивы и функции. Каждый объект имеет внутреннюю ссылку на свой **прототип** (наследование).

    Описать способы создания функционального конструктора классов.
    До появления синтаксиса классов в ES6 основным способом создания "класса" и объектов было использование **функциональных конструкторов**.
<!-- end list -->
1.  **Определение конструктора**: Создается обычная функция, но ее имя принято писать с **заглавной буквы** (для отличия от обычных функций).
    ```javascript
    function Car(brand, year) {
      // 2. Использование 'this' для определения свойств экземпляра
      this.brand = brand;
      this.year = year;
      // Методы, определенные здесь, будут создаваться для КАЖДОГО экземпляра
      this.getAge = function() {
        return new Date().getFullYear() - this.year;
      };
    }
    ```
2.  **Создание экземпляра**: Для создания объекта используется ключевое слово **`new`**.
    ```javascript
    let myCar = new Car("BMW", 2020);
    ```
**Важно**: Методы, которые должны быть общими для всех объектов (для экономии памяти), обычно добавляются через **прототип** конструктора (`Car.prototype.drive = function() { ... };`).

Описать прототипирование объектов.
**Прототипирование** — это механизм в JavaScript, с помощью которого объекты **наследуют свойства и методы** от других объектов. Это фундаментальный принцип наследования в JS.
  * Каждый объект в JavaScript имеет внутреннее свойство `[[Prototype]]` (доступное через `__proto__` или `Object.getPrototypeOf()`), которое ссылается на другой объект, называемый **прототипом**.
  * Когда мы обращаемся к свойству объекта, и оно не найдено в самом объекте, JavaScript автоматически ищет его в **цепочке прототипов** (Prototype Chain).
  * Для функциональных конструкторов, все, что добавлено в свойство **`Constructor.prototype`**, автоматически становится доступным для всех экземпляров, созданных этим конструктором.
  * **Преимущество**: Методы, определенные в прототипе, создаются **только один раз** и используются совместно всеми экземплярами, что экономит память.

    Описать наследование функциональных конструкторов, обычное и через прототип.
    Наследование с использованием функциональных конструкторов реализуется в два этапа:
<!-- end list -->
1.  **Обычное наследование (Наследование свойств)**: Вызов родительского конструктора внутри дочернего для копирования родительских свойств в новый объект.
    ```javascript
    function Parent(name) { this.name = name; }
    function Child(name, age) {
      Parent.call(this, name); // Вызов Parent, устанавливая 'this' как Child
      this.age = age;
    }
    ```
2.  **Наследование через прототип (Наследование методов)**: Установка прототипа дочернего конструктора на прототип родительского. Это позволяет дочернему объекту получить доступ к методам родителя.
    ```javascript
    // Child.prototype должен ссылаться на объект, который наследует от Parent.prototype
    Child.prototype = Object.create(Parent.prototype);
    // Восстановление ссылки на конструктор
    Child.prototype.constructor = Child;
    ```
Это гарантирует, что методы родителя доступны, а свойства родителя (которые часто являются уникальными) правильно инициализированы в каждом новом экземпляре дочернего класса.

Определить классы в языке JavaScript.
**Классы** — это синтаксический "сахар" (syntactic sugar), представленный в **ECMAScript 2015 (ES6)**, который предоставляет более чистый и привычный синтаксис для создания объектов и реализации наследования по сравнению с функциональными конструкторами и прототипами.
  * **Сущность**: Классы в JS не являются "настоящими" классами в том же смысле, как в C++ или Java. Они по-прежнему используют **прототипное наследование** под капотом, но предоставляют синтаксис, схожий с традиционным ООП.
  * **Структура**: Класс определяется ключевым словом **`class`**. Внутри него объявляется специальный метод **`constructor`** (для инициализации свойств) и другие **методы**.
  * **Использование**: Экземпляры создаются с помощью оператора **`new`**.
    ```javascript
    class Person {
      constructor(name) { this.name = name; }
      greet() { console.log(`Hello, ${this.name}`); }
    }
    let p = new Person("Alex");
    ```

    Описать наследование классов. Миксины.
<!-- end list -->
1.  **Наследование классов**: Реализуется с помощью ключевого слова **`extends`**. Дочерний класс наследует все свойства и методы родительского класса (Суперкласса).
      * Внутри конструктора дочернего класса обязательно должен быть вызван метод **`super()`**, который вызывает конструктор родителя для инициализации его свойств.
    <!-- end list -->
    ```javascript
    class Employee extends Person {
      constructor(name, id) {
        super(name); // Вызов конструктора Person
        this.id = id;
      }
    }
    ```
2.  **Миксины (Mixins)**: Это шаблон проектирования, который позволяет **внедрять (инжектировать) свойства и методы** из одного объекта (миксина) в другой класс, не используя прямое наследование (`extends`).
      * Миксины используются для обеспечения **многократного использования кода** и добавления поведения к классам, которые уже наследуют от другого родителя (так как JS не поддерживает множественное наследование классов).
      * **Реализация**: Обычно достигается путем копирования методов миксина в `prototype` целевого класса.

Описать класс Data. Пример использования.
Объект **`Date`** в JavaScript — это встроенный объект (по сути, класс), используемый для работы с датой и временем. Он хранит время в виде **количества миллисекунд**, прошедших с начала эпохи UNIX (01 января 1970 года, UTC).
  * **Создание объекта:**
      * `new Date()`: Создает объект с **текущей** датой и временем.
      * `new Date(year, month, day, ...)`: Создает объект с указанной датой (месяц нумеруется с 0, т.е. январь = 0).
      * `new Date(milliseconds)`: Создает объект на основе метки времени.
  * **Основные методы (для получения):**
      * `getFullYear()`: Возвращает год (4 цифры).
      * `getMonth()`: Возвращает месяц (от 0 до 11).
      * `getDate()`: Возвращает день месяца.
      * `getHours()`, `getMinutes()`, `getSeconds()`.
      * `getTime()`: Возвращает метку времени в миллисекундах.
  * **Основные методы (для установки):**
      * `setFullYear()`, `setMonth()`, `setDate()`, и т.д.
  * **Пример использования:**
    ```javascript
    let d = new Date();
    console.log("Сегодня: " + d.toLocaleDateString()); // Вывод даты в локальном формате
    let year = d.getFullYear(); // Получить текущий год
    ```

    Определить объектную модель BOM.
    **BOM (Browser Object Model)**, или Объектная Модель Браузера, — это набор объектов, которые предоставляются браузером для программного взаимодействия с **окном браузера** и средой, в которой выполняется JavaScript.
  * **Назначение**: Позволяет скрипту манипулировать не содержимым страницы (это делает DOM), а самим окном браузера, его историей, URL-адресом и информацией о браузере пользователя.
  * **Главный объект**: **`window`**. Все остальные объекты BOM являются его свойствами.
  * **Основные объекты BOM (свойства `window`):**
      * **`window`**: Глобальный объект, представляющий окно или вкладку.
      * **`location`**: Управление текущим URL.
      * **`history`**: Управление историей навигации.
      * **`navigator`**: Информация о браузере.
      * **`screen`**: Информация об экране пользователя.
      * **`setTimeout/setInterval`** (функции временной задержки).
        BOM не имеет официального стандарта W3C, в отличие от DOM.

Описать объект `window`.
Объект **`window`** является **глобальным объектом** в клиентском JavaScript и представляет собой **открытое окно или вкладку браузера** (viewport). Все глобальные переменные и функции, определенные в скрипте, становятся свойствами объекта `window`.
  * **Глобальный контекст:** Всякий раз, когда вы используете переменные или функции вне других функций, вы фактически обращаетесь к ним через `window` (например, `window.alert()`, `window.document`).
  * **Контейнер для BOM:** `window` является контейнером для всех объектов **BOM** (location, history, navigator, screen) и **DOM** (document).
  * **Функции управления окном:** Содержит методы для управления окном: `open()` (открыть новое окно), `close()` (закрыть текущее), `alert()`, `confirm()`, `prompt()`.
  * **Таймеры:** Включает методы для работы с временной задержкой: `setTimeout()` и `setInterval()`.

    Описать объекты history, location, screen, navigator.
    Эти объекты являются ключевыми компонентами **BOM** и предоставляют информацию о браузере, его истории и среде выполнения.
  * **`location`**: Предоставляет информацию о **текущем URL-адресе** страницы и методы для навигации.
      * Свойства: `href` (полный URL), `protocol`, `hostname`, `pathname`.
      * Методы: `assign(url)` (перейти на новый URL), `reload()` (перезагрузить страницу), `replace(url)` (перейти без сохранения в истории).
  * **`history`**: Позволяет управлять **историей сеансов** браузера (списком страниц, посещенных в текущей вкладке).
      * Методы: `back()` (перейти назад), `forward()` (перейти вперед), `go(n)` (перейти на n шагов).
  * **`screen`**: Предоставляет информацию об **экране** или дисплее пользователя.
      * Свойства: `width` (ширина экрана), `height` (высота экрана), `availWidth`, `availHeight` (доступная ширина/высота без панелей задач).
  * **`navigator`**: Содержит информацию о **браузере**, в котором выполняется скрипт, и операционной системе.
      * Свойства: `userAgent` (строка, идентифицирующая браузер), `platform`, `language`.
      * Используется для определения возможностей браузера.

    Определить модель DOM. Уровни. Структура документа.
    **DOM (Document Object Model)**, или Объектная Модель Документа, — это **программный интерфейс (API)** для HTML и XML-документов. DOM представляет документ в виде **логического древа (иерархии)** узлов, что позволяет программам и скриптам динамически обращаться к содержимому, структуре и стилям документа и изменять их.
  * **Уровни DOM (Исторически)**:
    1.  **Core DOM**: Определяет набор общих объектов для любого структурированного документа (HTML или XML).
    2.  **HTML DOM**: Добавляет специфические объекты и методы для работы с HTML-элементами (например, `document.forms`).
    3.  **Views, Events, Style, Traversal и Range**: Дополнительные модули, расширяющие возможности (например, обработка событий).
  * **Структура документа**: DOM представляет документ как **дерево узлов**.
      * **Узел документа (Document Node)**: Корень дерева (`document`).
      * **Узел элемента (Element Node)**: Представляет HTML-теги (`<div>`, `<p>`).
      * **Текстовый узел (Text Node)**: Содержит текст внутри элементов.
      * **Узел атрибута (Attribute Node)**: Представляет атрибуты элемента.

    Описать объект `document`.
    Объект **`document`** является **главным объектом DOM** и свойством объекта `window` (`window.document`). Он представляет собой загруженный **HTML-документ** целиком и служит **точкой входа** для любых манипуляций со страницей.
  * **Назначение**: Позволяет получать доступ, создавать, изменять и удалять HTML-элементы, управлять событиями и стилями.
  * **Основные методы для доступа к элементам:**
      * `getElementById('id')`: Найти элемент по его уникальному ID.
      * `getElementsByClassName('class')`: Найти коллекцию элементов по имени класса.
      * `getElementsByTagName('tag')`: Найти коллекцию элементов по имени тега.
      * `querySelector('selector')`: Найти **первый** элемент, соответствующий CSS-селектору.
      * `querySelectorAll('selector')`: Найти **коллекцию** элементов, соответствующих CSS-селектору.

    Описать навигацию по дереву документов. Создание узлов.
    **Навигация** — это процесс перемещения между узлами в дереве DOM для поиска нужного элемента относительно другого.
  * **Свойства для навигации:**
      * `parentNode`: Ссылка на родительский узел.
      * `children`: Коллекция дочерних **элементов** (пропускает текстовые и комментарии).
      * `firstChild` / `lastChild`: Первый / последний **узел** (включая текстовые и комментарии).
      * `nextElementSibling` / `previousElementSibling`: Следующий / предыдущий **элемент**-сосед (предпочтительнее, чем `nextSibling`).
  * **Создание узлов (Манипуляция DOM):**
      * `document.createElement('tagName')`: Создает новый узел элемента (например, `<div>` или `<p>`).
      * `document.createTextNode('text')`: Создает новый текстовый узел.
      * **Вставка узлов:**
          * `parent.appendChild(child)`: Добавляет новый узел **в конец** родителя.
          * `parent.insertBefore(newNode, referenceNode)`: Вставляет новый узел **перед** указанным опорным узлом.

    Описать процесс редактирование дерева элементов.
    Редактирование DOM включает изменение содержимого элементов, их атрибутов и удаление узлов.
<!-- end list -->
1.  **Изменение содержимого:**
      * `element.innerHTML = 'новый HTML'` (Изменяет содержимое, включая HTML-теги; потенциально небезопасно).
      * `element.textContent = 'только текст'` (Изменяет содержимое, интерпретируя данные только как чистый текст).
2.  **Изменение атрибутов:**
      * `element.setAttribute('name', 'value')`: Устанавливает или изменяет значение атрибута.
      * `element.getAttribute('name')`: Получает значение атрибута.
      * `element.removeAttribute('name')`: Удаляет атрибут.
      * **Прямое свойство:** Для стандартных атрибутов (ID, class, href) можно использовать прямые свойства: `element.id = 'newId'`, `element.className = 'newClass'`.
3.  **Удаление узлов:**
      * `element.remove()`: Удаляет сам элемент (современный метод).
      * `parent.removeChild(child)`: Удаляет указанный дочерний узел из родительского.

Описать работу с массивами элементов. Привести пример.
Когда вы используете методы `document.getElementsByClassName()`, `document.getElementsByTagName()` или `document.querySelectorAll()`, они возвращают не стандартный JavaScript-массив (`Array`), а похожий на массив объект: **`HTMLCollection`** или **`NodeList`**. Эти коллекции называют "массивами элементов".
  * **Особенности:** Они похожи на массивы (имеют числовые индексы и свойство `length`), но **не имеют** методов стандартного массива (`map`, `filter`, `reduce`).
  * **Преобразование в Array (для использования методов):**
      * **Современный способ (ES6):** Используйте оператор spread: `let arr = [...nodeList];`
      * **Классический способ:** Используйте метод `Array.from()`: `let arr = Array.from(nodeList);`
  * **Пример:**
    ```javascript
    let divs = document.querySelectorAll('div'); // NodeList
    // Ошибка: divs.map is not a function
    // Преобразование и использование map
    let classNames = [...divs].map(div => div.className);
    console.log(classNames);
    ```

    Определить обработку событий при помощи JavaScript.
    **Обработка событий** — это механизм, который позволяет JavaScript-коду реагировать на действия пользователя (например, клик мышью, ввод) или на системные события (загрузка страницы, изменение размера).
  * **Событие** — это сигнал, который генерируется элементом.
  * **Обработчик (Handler)** — это функция, которая будет выполнена, когда произойдет событие.
  * **Три основных способа назначения обработчиков:**
    1.  **Встроенный в HTML атрибут:** `<button onclick="handlerFunction()">` (Устаревший, не рекомендуется).
    2.  **DOM-свойство:** `element.onclick = handlerFunction;` (Позволяет назначить только **один** обработчик).
    3.  **Метод `addEventListener` (Рекомендуется):** `element.addEventListener('click', handlerFunction);` (Позволяет назначить **несколько** обработчиков на одно событие и лучше разделяет код).

    Описать объект event. Обработка событий.
    Когда происходит событие, браузер создает специальный **объект события (`event`)** и передает его как аргумент функции-обработчику. Этот объект содержит всю необходимую информацию о произошедшем событии.
  * **Основные свойства объекта `event`:**
      * `event.type`: Тип события (например, 'click', 'mouseover', 'submit').
      * `event.target`: Элемент, на котором произошло событие.
      * `event.currentTarget`: Элемент, на котором установлен обработчик (может отличаться от `target` при всплытии).
      * `event.clientX` / `event.clientY`: Координаты курсора мыши.
  * **Обработка событий (методы):**
      * `event.preventDefault()`: **Отменяет действие браузера по умолчанию** для этого события (например, предотвращает отправку формы или переход по ссылке).
      * `event.stopPropagation()`: **Останавливает всплытие** события по дереву DOM, предотвращая его обработку родительскими элементами.

    Описать обращение к элементам формы из JavaScript.
    Доступ к элементам формы необходим для чтения, записи или проверки вводимых пользователем данных. Существует несколько способов:
<!-- end list -->
1.  **По ID (самый надежный):**
    ```javascript
    let inputField = document.getElementById('myInputField');
    ```
2.  **Через коллекцию форм и элементов:**
      * Сам тег `<form>` доступен через `document.forms['formName']`.
      * Элементы внутри формы доступны по имени:
    <!-- end list -->
    ```javascript
    let form = document.forms['myForm'];
    let inputField = form.elements['inputName'];
    ```
3.  **Через объект события:**
    При обработке события `submit`, `event.target` ссылается на саму форму:
    ```javascript
    document.querySelector('form').addEventListener('submit', function(event) {
        let form = event.target;
        let username = form.elements.username.value;
    });
    ```

Описать обработку форм на стороне клиента, доступ к данным формы.
**Обработка формы на стороне клиента (Client-side Processing)** — это процесс сбора, валидации и предварительной обработки данных, введенных пользователем в форму, **до того, как эти данные будут отправлены на сервер**. Этот подход повышает **отзывчивость** интерфейса и снижает нагрузку на сервер, предотвращая отправку заведомо некорректных данных.
**Доступ к данным формы:**
1.  **Получение ссылки на элемент:** Используя DOM (например, `document.getElementById('id')` или доступ через коллекцию `document.forms['formName'].elements['fieldName']`).
2.  **Чтение значения:** Получение введенных данных осуществляется через свойство **`.value`** для большинства полей (`<input type="text">`, `<textarea>`).
      * Для чекбоксов и радиокнопок используется свойство **`.checked`** (булево значение).
      * Для выпадающих списков (`<select>`) можно получить выбранное значение также через `.value`.
3.  **Валидация:** После сбора данных JS выполняет проверку их формата, наличия и соответствия правилам (например, соответствует ли поле email паттерну).

Описать валидацию форм, регулярные выражения.
**Валидация форм** — это процесс проверки правильности и корректности данных, введенных пользователем, перед их обработкой (обычно перед отправкой на сервер). Она может выполняться как на стороне клиента (JS/HTML5), так и на стороне сервера (PHP).
  * **Клиентская валидация (JS/HTML5)**: Обеспечивает мгновенную обратную связь. HTML5-атрибуты (`required`, `minlength`, `pattern`) предоставляют базовые проверки, но для сложных правил используется JavaScript.
  * **Регулярные выражения (RegExp)**: Являются основным инструментом для выполнения сложных проверок формата. **Регулярное выражение** — это последовательность символов, которая определяет шаблон поиска.
      * **Назначение**: Используются для проверки, соответствует ли введенная строка определенному формату (например, корректности email, номера телефона, или сложности пароля).
      * **Пример использования в JS**:
        ```javascript
        const emailPattern = /^\S+@\S+\.\S+$/;
        if (!emailPattern.test(inputValue)) {
           // Ошибка валидации
        }
        ```

    Определить promises и fech в JavaScript.
    **Promises (Промисы)** — это объекты в JavaScript, представляющие конечное **успешное завершение** или **неудачу** асинхронной операции. Они решают проблему "Ада колбэков" (Callback Hell), делая асинхронный код более структурированным и читаемым.
  * **Состояния Promise:** **Pending** (ожидание), **Fulfilled** (успешно завершен), **Rejected** (завершился с ошибкой).
  * **Обработка:** Результат Promise обрабатывается методами `.then()` (для успеха) и `.catch()` (для ошибки).
    **Fetch API** — это современный, основанный на промисах, интерфейс для выполнения **сетевых запросов** (HTTP-запросы) из браузера.
  * **Назначение:** Полностью заменяет устаревший `XMLHttpRequest` (XHR).
  * **Принцип работы:** Метод `fetch()` принимает URL и возвращает **Promise**, который резолвится в объект **`Response`** (даже при ошибке 404). Для получения тела данных (JSON или текст) требуется второй асинхронный шаг (`response.json()` или `response.text()`), который также возвращает Promise.
    
    Описать обработку ошибок в JavaScript.
    Обработка ошибок необходима для того, чтобы приложение не "падало" при возникновении непредвиденных ситуаций.
    **Основной механизм:** Конструкция **`try...catch...finally`**.
<!-- end list -->
1.  **`try`**: Блок кода, который может потенциально вызвать ошибку (исключение).
2.  **`catch (err)`**: Если в блоке `try` возникает ошибка, выполнение немедленно переходит сюда. Переменная `err` содержит объект ошибки с информацией. Используется для логирования, уведомления пользователя и восстановления работы.
3.  **`finally`**: Блок кода, который **всегда выполняется** после завершения `try` и `catch`, независимо от того, произошла ошибка или нет. Часто используется для очистки ресурсов (например, закрытия файла).
    **Современный подход:** Для асинхронного кода (Promises, Fetch, async/await) ошибки также обрабатываются с помощью `.catch()` или с помощью `try...catch` внутри `async` функции.

Определить асинхронные функции, формат JSON.
**Асинхронные функции (`async`/`await`):**
  * Это синтаксический "сахар" над Promises, представленный в ES8.
  * **`async`**: Ключевое слово, ставится перед функцией. Такая функция **всегда возвращает Promise**.
  * **`await`**: Ключевое слово, может использоваться **только внутри** `async` функции. Оно заставляет выполнение функции **приостановиться**, пока Promise не будет разрешен (Fulfilled) или отклонен (Rejected), что позволяет писать асинхронный код, который выглядит как синхронный.
    **JSON (JavaScript Object Notation):**
  * **Формат данных:** Легковесный, текстовый формат обмена данными, основанный на синтаксисе объектов JavaScript.
  * **Назначение:** Используется для передачи данных между сервером и веб-приложением.
  * **Структура:** Данные представляются в виде пар **"ключ: значение"**, объектов (`{}`) и массивов (`[]`). Все ключи должны быть заключены в **двойные кавычки**.
  * **Работа в JS:**
      * `JSON.stringify(obj)`: Преобразует объект JavaScript в строку JSON.
      * `JSON.parse(string)`: Преобразует строку JSON обратно в объект JavaScript.

    Определить Web-сервер, настройка и запуск.
    **Web-сервер** — это программное обеспечение (или аппаратный комплекс), которое принимает **HTTP-запросы** от клиентов (браузеров) и доставляет им **HTTP-ответы**, обычно в виде HTML-страниц, изображений и других ресурсов.
  * **Примеры:** Apache HTTP Server, Nginx, Microsoft IIS, Node.js (с Express).
  * **Настройка (Конфигурирование):** Включает определение следующих параметров:
    1.  **Корневая директория (Document Root)**: Папка на диске, где хранятся публично доступные файлы сайта.
    2.  **Порт прослушивания**: TCP-порт, на котором сервер ожидает запросы (по умолчанию 80 для HTTP, 443 для HTTPS).
    3.  **Виртуальные хосты**: Настройка для обслуживания нескольких доменов на одном физическом сервере.
  * **Запуск:** Осуществляется путем выполнения исполняемого файла сервера или, чаще, как системный сервис (демон) в фоновом режиме.

    Описать PHP синтаксис и типы данных.
    **PHP (Hypertext Preprocessor)** — это серверный скриптовый язык программирования, используемый в основном для создания динамических веб-страниц.
  * **Синтаксис:** PHP-код должен быть заключен в специальные теги: **`<?php`** и **`?>`**. Все переменные начинаются со знака доллара (**`$`**). Инструкции завершаются точкой с запятой (**`;`**).
  * **Типы данных (8 основных типов):**
    1.  **Скалярные (Scalar Types):**
          * **Boolean**: `true` или `false`.
          * **Integer**: Целые числа.
          * **Float (double)**: Числа с плавающей точкой.
          * **String**: Строки, могут быть заключены в одинарные (`''`) или двойные (`""`) кавычки.
    2.  **Составные (Compound Types):**
          * **Array**: Массив (может быть индексированным или ассоциативным).
          * **Object**: Экземпляр класса.
    3.  **Специальные (Special Types):**
          * **Resource**: Ссылка на внешний ресурс (например, соединение с БД).
          * **NULL**: Переменная без значения.

    Описать обработку форм в PHP.
    Обработка форм в PHP происходит на стороне сервера и зависит от HTTP-метода, указанного в форме (GET или POST).
    **Механизм доступа к данным:** PHP автоматически заполняет **суперглобальные массивы** данными, отправленными формой:
<!-- end list -->
1.  **`$_GET`**: Используется, если форма отправлена методом **GET**. Данные приходят в URL.
2.  **`$_POST`**: Используется, если форма отправлена методом **POST**. Данные приходят в теле запроса.
    **Процесс обработки:**
3.  **Проверка отправки:** Проверка, была ли форма вообще отправлена, обычно через `isset($_POST['submitButtonName'])` или проверку наличия данных в массиве: `if ($_SERVER['REQUEST_METHOD'] == 'POST')`.
4.  **Сбор данных:** Получение данных из суперглобальных массивов: `$username = $_POST['username'];`.
5.  **Валидация и очистка:** Проверка данных на соответствие требованиям и их очистка (санитизация) для предотвращения уязвимостей (например, SQL-инъекций, XSS).

Описать работу с массивами в PHP.
Массивы в PHP очень гибкие и являются по сути упорядоченными **ассоциативными картами**.

  * **Виды массивов:**
    1.  **Индексированный (Indexed)**: Элементы нумеруются целыми числами, начиная с 0. `$a = ['apple', 'banana'];`.
    2.  **Ассоциативный (Associative)**: Элементы идентифицируются строковыми ключами. `$user = ['name' => 'Alice', 'age' => 30];`.
  * **Основные функции и операции:**
      * **Обход:** Цикл **`foreach`** является основным для перебора элементов.
      * **Счет:** `count($array)` возвращает количество элементов.
      * **Добавление/Удаление:** `array_push()` (в конец), `array_pop()` (из конца), `unset()` (удаление элемента по ключу).
      * **Слияние/Извлечение:** `array_merge()` (объединение), `array_keys()`, `array_values()`.
      * **Проверка:** `isset($array['key'])` (проверка существования ключа), `in_array($value, $array)` (проверка существования значения).

    Описать работу со строками в PHP.
    Строки в PHP могут быть заключены как в одинарные (`'...'`), так и в двойные (`"..."`) кавычки. Двойные кавычки позволяют **интерпретацию переменных** внутри строки (`"Hello, $name"`).
  * **Конкатенация (Объединение):** Используется оператор **точка (`.`)**.
    ```php
    $greeting = "Hello, " . $name . "!";
    ```
  * **Основные строковые функции:**
      * `strlen($string)`: Возвращает **длину** строки.
      * `strpos($haystack, $needle)`: Находит **первое вхождение** подстроки.
      * `substr($string, start, length)`: **Извлекает** часть строки.
      * `str_replace($search, $replace, $string)`: **Заменяет** все вхождения подстроки.
      * `trim($string)`: **Удаляет пробелы** и другие символы с начала и конца строки.
      * `strtolower()` / `strtoupper()`: Преобразует в нижний/верхний регистр.
      * `htmlspecialchars()`: Используется для **очистки (санитизации)** данных, предотвращая XSS-атаки.

Описать работу с файлами и каталогами в PHP.
PHP предоставляет богатый набор функций для взаимодействия с файловой системой сервера.
  * **Работа с файлами (Низкоуровневая)**:
      * **`fopen(filename, mode)`**: Открывает файл для чтения или записи. `mode` может быть 'r' (чтение), 'w' (запись, перезапись), 'a' (добавление).
      * **`fclose(handle)`**: Закрывает файловый указатель (ресурс), освобождая его.
      * **`fwrite(handle, string)` / `fputs(...)`**: Записывает данные в открытый файл.
      * **`fread(handle, length)`**: Читает указанное количество байт из файла.
  * **Работа с файлами (Высокоуровневая, удобная)**:
      * **`file_get_contents(filename)`**: Считывает **всё содержимое** файла в строку.
      * **`file_put_contents(filename, data)`**: Записывает строку в файл (создает его или перезаписывает).
  * **Работа с каталогами (папками)**:
      * **`mkdir(dirname)`**: Создает новый каталог.
      * **`rmdir(dirname)`**: Удаляет пустой каталог.
      * **`scandir(dirname)`**: Возвращает **массив** файлов и каталогов внутри указанной директории.
      * **`is_dir(path)`** / **`is_file(path)`**: Проверяет, является ли путь каталогом или файлом.

    Описать процесс обработки ошибок в PHP.
    В PHP существует два основных механизма реагирования на проблемы: **Ошибки (Errors)** и **Исключения (Exceptions)**.
<!-- end list -->
1.  **Ошибки (Errors)**: Исторический механизм для серьезных проблем (синтаксические ошибки, нехватка памяти). Управляются настройками PHP:
      * **`error_reporting(level)`**: Устанавливает, какие типы ошибок должны быть отображены.
      * **`ini_set('display_errors', 1)`**: Определяет, будут ли ошибки показаны пользователю.
      * **Обработчик ошибок**: Функция **`set_error_handler(callback)`** позволяет перехватить стандартные PHP-ошибки и обрабатывать их как исключения.
2.  **Исключения (Exceptions)**: Современный, объектно-ориентированный механизм для обработки предсказуемых проблем (отсутствие файла, ошибка БД).
      * Используется конструкция **`try...catch`**:
        ```php
        try {
            // Код, который может сгенерировать исключение (throw new Exception)
        } catch (Exception $e) {
            // Обработка исключения ($e->getMessage())
        } finally {
            // Выполняется всегда
        }
        ```

Описать работу со временем в PHP.
PHP предоставляет несколько способов работы с датами и временем.
1.  **Метки времени UNIX (Timestamp)**: Представляют собой количество секунд, прошедших с 1 января 1970 года.
      * **`time()`**: Возвращает текущую метку времени UNIX.
2.  **Функциональный подход**:
      * **`date(format, timestamp)`**: Форматирует метку времени в читаемую строку. Формат (например, 'Y-m-d H:i:s').
      * **`strtotime(string)`**: Преобразует строку с датой и временем ("next Monday", "now") в метку времени UNIX.
3.  **Объектно-ориентированный подход (Класс `DateTime`)**: Рекомендуемый современный метод, более гибкий и надежный.
      * **`$date = new DateTime();`**: Создает объект с текущим временем.
      * **`$date->format('Y-m-d')`**: Форматирование.
      * **`$date->modify('+1 day')`**: Изменение даты.
      * Класс `DateInterval` используется для работы с интервалами времени.

Описать работу с cookie в PHP, создание и использование.
**Cookie** — это небольшие фрагменты текстовых данных, которые **сервер отправляет браузеру** и которые браузер сохраняет. При каждом последующем запросе к тому же домену браузер отправляет эти Cookie обратно на сервер. Используются для хранения состояния, идентификации пользователей и отслеживания.
  * **Создание (Установка) Cookie**: Используется функция **`setcookie()`**. Она должна быть вызвана **до** того, как будет отправлен какой-либо вывод в браузер (до HTML):
    ```php
    setcookie("user_name", "Alex", time() + 3600); // Имя, Значение, Время жизни (1 час)
    ```
  * **Использование (Чтение) Cookie**: Установленные Cookie становятся доступны в суперглобальном массиве **`$_COOKIE`** при следующем запросе.
    ```php
    $username = $_COOKIE['user_name'] ?? 'Guest'; // Чтение значения
    ```
  * **Удаление Cookie**: Вызывается `setcookie()` с тем же именем, но с временем жизни в прошлом:
    ```php
    setcookie("user_name", "", time() - 3600);
    ```

    Описать работу с аутентификацией в PHP.
    **Аутентификация** — это процесс проверки личности пользователя (т.е. он тот, за кого себя выдает).
<!-- end list -->
1.  **Сбор данных**: Пользователь вводит логин и пароль в форму (отправка методом POST).
2.  **Получение данных**: PHP получает данные через `$_POST`.
3.  **Хеширование пароля**: Пароль, введенный пользователем, должен быть **хеширован** (например, функцией `password_hash()`), поскольку хранение паролей в чистом виде (plain text) недопустимо.
4.  **Проверка в БД**: Хешированный пароль сравнивается с хешем, хранящимся в базе данных, с помощью функции **`password_verify($password, $hashFromDB)`**.
5.  **Создание сессии**: Если пароли совпали, создается **сессия** (`session_start()`), и в `$_SESSION` записывается флаг авторизации и идентификатор пользователя.
6.  **Авторизация**: На каждой последующей странице проверяется наличие и корректность сессионных данных для предоставления доступа к защищенным ресурсам.

Описать работу с сессиями.
**Сессия** — это механизм, который позволяет серверу **сохранять данные о состоянии пользователя** между несколькими HTTP-запросами. HTTP является "безграмотным" (stateless), поэтому сессии необходимы для поддержания состояния (например, корзина, авторизация).
  * **Принцип работы**:
    1.  **Запуск**: На каждой странице, где нужны данные сессии, вызывается **`session_start()`**.
    2.  **Идентификация**: PHP генерирует уникальный **ID сессии** и отправляет его клиенту (обычно в виде Cookie с именем PHPSESSID).
    3.  **Хранение данных**: Данные сессии хранятся **на сервере** (в файле или БД) и доступны через суперглобальный массив **`$_SESSION`**.
    <!-- end list -->
      * **Пример хранения**: `$_SESSION['user_id'] = 123;`.
  * **Завершение**: Сессия уничтожается функцией **`session_destroy()`** (например, при выходе пользователя).

    Определить протокол oAuth.
    **OAuth (Open Authorization)** — это **открытый стандарт (протокол)** для **авторизации**, который позволяет приложению (Клиенту) получить **ограниченный доступ** к ресурсам пользователя (например, Google, GitHub, ВКонтакте) без необходимости передавать приложению сам пароль пользователя.
  * **Назначение**: Реализует концепцию "входа через...". Пользователь дает разрешение (Authorization Grant) одному сервису получить доступ к его данным на другом сервисе.
  * **Роли (4 основные):**
    1.  **Resource Owner (Владелец ресурса)**: Сам пользователь.
    2.  **Client (Клиент)**: Приложение, которое хочет получить доступ (твой сайт).
    3.  **Authorization Server (Сервер авторизации)**: Сервис, который выдает токены (Google, Facebook).
    4.  **Resource Server (Сервер ресурсов)**: Сервис, где хранятся данные пользователя (почта, фото).
  * **Результат**: Клиент получает **токен доступа (Access Token)**, который используется для совершения запросов от имени пользователя.

    Описать принцип работы с почтовыми сервисами.
    Для отправки электронной почты с веб-сервера можно использовать два основных подхода:
<!-- end list -->
1.  **Функция `mail()` (Простой метод)**:
      * В PHP существует встроенная функция **`mail(to, subject, message, headers)`**.
      * **Ограничение**: Для работы требует, чтобы на сервере был настроен и запущен локальный почтовый агент (MTA, например, Sendmail). Часто сообщения, отправленные через `mail()`, попадают в спам.
2.  **SMTP (Simple Mail Transfer Protocol) через внешние библиотеки (Рекомендуется)**:
      * Наиболее надежный метод. Используется библиотека, такая как **PHPMailer** или Symfony Mailer.
      * **Принцип**: Скрипт подключается к внешнему специализированному почтовому сервису (SMTP-серверу, например, Gmail, SendGrid, Mailgun) с использованием **аутентификации** (логин/пароль или API ключ).
      * **Преимущество**: Высокая доставляемость, возможность отслеживания и правильная обработка заголовков.

Описать работу с БД в PHP, подключение и конфигурирование.
Для работы с базами данных (например, MySQL, PostgreSQL) PHP использует специальные расширения.
  * **Основные расширения (API):**
    1.  **MySQLi (MySQL Improved)**: Расширение, специализированное для работы только с MySQL. Может использоваться в процедурном или объектно-ориентированном стиле.
    2.  **PDO (PHP Data Objects)**: **Рекомендуемое** расширение. Это **универсальный уровень абстракции** базы данных, который позволяет работать с разными типами БД (MySQL, PostgreSQL, SQLite) через единый интерфейс.
  * **Подключение и конфигурирование (Пример PDO):**
    Подключение выполняется через создание нового объекта PDO. Конфигурация требует указания:
      * **DSN (Data Source Name)**: Тип БД, хост и имя базы данных.
      * **Логин пользователя БД**.
      * **Пароль пользователя БД**.
    <!-- end list -->
    ```php
    $dsn = 'mysql:host=localhost;dbname=testdb;charset=utf8';
    $user = 'db_user';
    $password = 'db_pass';
    try {
        $pdo = new PDO($dsn, $user, $password);
    } catch (PDOException $e) {
        die("Ошибка подключения: " . $e->getMessage());
    }
    ```

    Описать обработку ошибок подключения к БД, выполнение запросов.
    Правильная обработка ошибок критически важна для безопасности и надежности приложения.
<!-- end list -->
1.  **Ошибки подключения:**
      * **С PDO**: Обрабатываются с помощью конструкции **`try...catch`**, как показано выше. Ошибка `PDOException` перехватывается, и пользовательское сообщение выводится вместо технической информации.
      * **С MySQLi**: Проверяется свойство **`connect_error`** после вызова конструктора.
2.  **Ошибки выполнения запросов (SQL):** Возникают, если SQL-запрос синтаксически неверен, или нарушены ограничения БД.
      * **PDO**: Установка режима ошибок `PDO::ERRMODE_EXCEPTION` заставляет PDO генерировать исключения при ошибке запроса. Это позволяет использовать **`try...catch`** и для запросов.
      * **Выполнение запросов**:
          * **`$pdo->query(...)`**: Для простых запросов (SELECT).
          * **`$pdo->prepare(...)`** и **`$stmt->execute(...)`**: **Рекомендуемый** метод. Используется для параметризованных запросов (prepared statements), которые **автоматически предотвращают SQL-инъекции**. Ошибки проверяются после выполнения.

Ошибки подключения возникают, когда PHP-скрипт не может установить соединение с сервером базы данных (неверный хост, логин, пароль или недоступность сервера).
  * **С PDO (PHP Data Objects)**:
      * Ошибки подключения генерируют исключение **`PDOException`**.
      * Обработка должна производиться с помощью конструкции **`try...catch`** при создании объекта `PDO`, чтобы предотвратить отображение чувствительной информации (учетные данные) пользователю.
    <!-- end list -->
    ```php
    try {
        $pdo = new PDO($dsn, $user, $password);
    } catch (PDOException $e) {
        die("Ошибка подключения к БД."); // Скрываем $e->getMessage() от пользователя
    }
    ```
  * **С MySQLi**:
      * Проверяется свойство **`connect_error`** после вызова конструктора.
    <!-- end list -->
    ```php
    $mysqli = new mysqli($host, $user, $pass, $db);
    if ($mysqli->connect_error) {
        die('Ошибка подключения (' . $mysqli->connect_errno . ') ');
    }
    ```
Ошибки выполнения запросов возникают после успешного подключения, если SQL-запрос синтаксически неверен, или нарушены ограничения БД (например, UNIQUE-ключ).
  * **PDO (Рекомендуемый подход)**:
      * Необходимо установить режим ошибок **`PDO::ERRMODE_EXCEPTION`** при инициализации, чтобы PDO генерировал исключения при ошибке запроса. Это позволяет использовать ту же конструкцию **`try...catch`** для всех SQL-операций.
      * **Выполнение запросов**: Для обеспечения безопасности используются **подготовленные выражения (Prepared Statements)** (`$pdo->prepare(...)` и `$stmt->execute(...)`), которые **автоматически предотвращают SQL-инъекции**. Ошибки проверяются после выполнения.
  * **MySQLi**:
      * Необходимо проверять возвращаемое значение метода **`query()`** (который вернет `FALSE` в случае ошибки) и использовать метод **`$mysqli->error`** для получения текста ошибки.
В любом случае, при возникновении ошибки **критически важно** **не выводить технические данные** об ошибке (особенно SQL-код, имена таблиц или пароли) конечному пользователю. Вместо этого ошибка должна быть **зарегистрирована** (logged) в файле на сервере, а пользователю должно быть показано общее, нейтральное сообщение.